\documentclass{article}

\setlength{\oddsidemargin}{0 in} % odd page left margin
\setlength{\evensidemargin}{0 in} % even page left margin
\setlength{\textwidth}{6 in}    % width of text

\title{HVTN065 Summary}

\begin{document}

\maketitle
 
<<setup, include=FALSE, cache=FALSE, echo=FALSE, warning=FALSE>>=
opts_chunk$set(fig.align = 'center', dev = 'png', #fig.show = 'hold',
               message = FALSE, warning = FALSE, cache = FALSE,
               echo = FALSE, fig.path = 'figure/HVTN065-',
               cache.path = 'cache/HVTN065-')
  
setwd("..")
library(ProjectTemplate)
load.project()
@ 

\section{Population Statistics}

<<population_stats_summary>>=
# We prettify the population stats, so that they have a reduced number of nodes
# in the output.
HVTN065_population_stats <- lapply(HVTN065_population_stats, pretty_popstats,
                                   nodes = 2)
m_pop_stats <- melt(HVTN065_population_stats)
colnames(m_pop_stats) <- c("Marker", "Sample", "Proportion", "Stimulation")
m_pop_stats <- subset(m_pop_stats, select = -c(Stimulation))
m_pop_stats$Marker <- as.character(m_pop_stats$Marker)
m_pop_stats <- subset(m_pop_stats, Marker != "root")

colnames(HVTN065_pData_gs_manual) <- c("Sample", "PTID", "Stimulation", "VISITNO")
m_pop_stats <- plyr:::join(m_pop_stats, HVTN065_pData_gs_manual, by = "Sample")
m_pop_stats$VISITNO <- factor(m_pop_stats$VISITNO)
m_pop_stats$PTID <- factor(m_pop_stats$PTID)

# Summarizes the proportions for each marker.
summary_by_marker <- ddply(m_pop_stats, .(Marker, Stimulation, VISITNO), summarize,
                           Mean = mean(Proportion), Median = median(Proportion),
                           CV = sd(Proportion) / mean(Proportion))

# We breakdown the markers into groups so that the plot is cleaner and better
# organized.
summary_by_marker$marker_group <- "Other"
summary_by_marker$marker_group <- with(summary_by_marker,
                                  replace(marker_group, grep("CD4", Marker), "CD4"))
summary_by_marker$marker_group <- with(summary_by_marker,
                                  replace(marker_group, grep("CD8", Marker), "CD8"))

m_pop_stats$marker_group <- "Other"
m_pop_stats$marker_group <- with(m_pop_stats,
                                 replace(marker_group, grep("CD4", Marker), "CD4"))
m_pop_stats$marker_group <- with(m_pop_stats,
                                 replace(marker_group, grep("CD8", Marker), "CD8"))

# To make the plots cleaner, we manually add the following markers to the "Other" group, so that they are shown
# with the top-level markers.
m_pop_stats$marker_group[m_pop_stats$Marker %in% c("CD3/CD4", "CD3/CD8", "CD3/not CD4", "not CD4/IFNg")] <- "Other"
summary_by_marker$marker_group[summary_by_marker$Marker %in% c("CD3/CD4", "CD3/CD8", "CD3/not CD4", "not CD4/IFNg")] <- "Other"

# Now, that we have grouped the markers by the CD4/CD8 subpopulations (if
# applicable), we remove redundant information from the 'Marker' string.
m_pop_stats$Marker <- sapply(strsplit(m_pop_stats$Marker, split = ":"), tail, n = 1)
summary_by_marker$Marker <- sapply(strsplit(summary_by_marker$Marker, split = ":"), tail, n = 1)

m_pop_stats$Marker <- sapply(strsplit(m_pop_stats$Marker, split = "/"), tail, n = 1)
summary_by_marker$Marker <- sapply(strsplit(summary_by_marker$Marker, split = "/"), tail, n = 1)

# For each patient, we average the proportions across stimulation groups for each visit number.
# This produces a cleaner summary of the difference in proportions between visits 2 and 12 across patients.
prop_summary <- ddply(m_pop_stats, .(Marker, PTID, VISITNO), summarize, avg_prop = mean(Proportion))
@ 

<<CV_by_marker>>=
p1 <- ggplot(subset(summary_by_marker, marker_group == "Other"), aes(x = Marker, fill = VISITNO))
p1 <- p1 + geom_bar(aes(weight = CV), position = "dodge")
p1 <- p1 + theme(axis.text.x = element_text(angle = 90)) + ylab("Coefficient of Variation")
p1 <- p1 + facet_grid(Stimulation ~ .) + ggtitle("Gates")
p1
  
p2 <- ggplot(subset(summary_by_marker, marker_group == "CD4"), aes(x = Marker, fill = VISITNO))
p2 <- p2 + geom_bar(aes(weight = CV), position = "dodge")
p2 <- p2 + theme(axis.text.x = element_text(angle = 90)) + ylab("Coefficient of Variation")
p2 <- p2 + facet_grid(Stimulation ~ .) + ggtitle("CD4 Gates")
p2

p3 <- ggplot(subset(summary_by_marker, marker_group == "CD8"), aes(x = Marker, fill = VISITNO))
p3 <- p3 + geom_bar(aes(weight = CV), position = "dodge")
p3 <- p3 + theme(axis.text.x = element_text(angle = 90)) + ylab("Coefficient of Variation")
p3 <- p3 + facet_grid(Stimulation ~ .) + ggtitle("CD8 Gates")
p3
@ 

\section{Subject Proportions by Visit Number}

<<proportions_by_visit>>=
p <- ggplot(prop_summary, aes(x = PTID, fill = VISITNO)) + geom_bar(aes(weight = avg_prop), position = "dodge")
p <- p + facet_wrap(~ Marker, scale = "free") + theme_bw()
p + theme(axis.text.x = element_text(angle = 90)) + ylab("Average Proportion Across Stimulation Groups")
@ 

\section{Classification Summary}

<<classification_summary>>=
class_data <- dcast(m_pop_stats, PTID + VISITNO ~ Marker, mean, value.var = "Proportion")

# We randomly choose 50% of patients as training data and the remaining patients as test data
set.seed(42)
train_pct <- 1/2
patients <- levels(class_data$PTID)
num_patients <- length(patients)
patients_train <- sample.int(num_patients, train_pct * num_patients)

train_data <- subset(class_data, PTID %in% patients[patients_train])
test_data <- subset(class_data, PTID %in% patients[-patients_train])

train_x <- as.matrix(subset(train_data, select = -c(PTID, VISITNO)))
train_y <- train_data$VISITNO

test_x <- as.matrix(subset(test_data, select = -c(PTID, VISITNO)))
test_y <- test_data$VISITNO

glmnet_cv <- cv.glmnet(x = train_x, y = train_y, family = "binomial")

# TODO: Select the optimal CV values and predict from 
glmnet_fit <- glmnet(x = train_x, y = train_y, family = "binomial")

# Plots the cross-validation fit from glmnet
plot(glmnet_cv)

# Determines which features should be kept for classification
# If present, we manually remove the "(Intercept)"
coef_glmnet <- coef(glmnet_cv)
markers_kept <- rownames(coef_glmnet)[as.vector(coef_glmnet) != 0]
markers_kept <- markers_kept[!grepl("(Intercept)", markers_kept)]

# We apply 10-fold cross-validation using the 'trainControl' from the 'caret'
# package to select the optimal features with the 'glmnet' classifier.
fitControl <- trainControl(method = "cv", number = 10)
glmnet_fit <- train(VISITNO ~ . - PTID, data = train_data, method = "glmnet", trControl = fitControl)





@ 


\end{document}
