\documentclass{article}

\setlength{\oddsidemargin}{0 in} % odd page left margin
\setlength{\evensidemargin}{0 in} % even page left margin
\setlength{\textwidth}{6 in}    % width of text

\title{HVTN065 Summary}

\begin{document}

\pagenumbering{gobble} % Remove page numbers (and reset to 1)

\maketitle
 
<<setup, include=FALSE, cache=FALSE, echo=FALSE, warning=FALSE>>=
opts_chunk$set(fig.align = 'default', dev = 'png', message = FALSE, warning = FALSE,
               cache = FALSE, echo = FALSE, fig.path = 'figure/HVTN065-',
               cache.path = 'cache/HVTN065-', fig.width = 7.5, fig.height = 9.25,
               out.width = "7.5in", out.height = "9.25in")
  
setwd("..")
library(ProjectTemplate)
load.project()
@ 

<<population_stats_summary>>=
# We prettify the population stats, so that they have a reduced number of nodes
# in the output.
popstats_HVTN065 <- pretty_popstats(popstats_HVTN065, nodes = 4)
m_pop_stats <- melt(popstats_HVTN065)
colnames(m_pop_stats) <- c("Marker", "Sample", "Proportion")
m_pop_stats$Marker <- as.character(m_pop_stats$Marker)
m_pop_stats <- subset(m_pop_stats, Marker != "root")

colnames(pData_HVTN065) <- c("Sample", "PTID", "Stimulation", "VISITNO")
m_pop_stats <- plyr:::join(m_pop_stats, pData_HVTN065, by = "Sample")
m_pop_stats$VISITNO <- factor(m_pop_stats$VISITNO)
m_pop_stats$PTID <- factor(m_pop_stats$PTID)

# We stored the 'negctrl' with sample numbers appended to the strings so that
# plotGate could identify unique samples. Here, we strip the sample numbers to
# summarize the negative controls as a whole.
m_pop_stats$Stimulation <- with(m_pop_stats, replace(Stimulation, grep("^negctrl", Stimulation), "negctrl"))

# Summarizes the proportions for each marker.
summary_by_marker <- ddply(m_pop_stats, .(Marker, Stimulation, VISITNO), summarize,
                           CV = sd(Proportion) / mean(Proportion))

# For each patient, we average the proportions across stimulation groups for each visit number.
# This produces a cleaner summary of the difference in proportions between visits 2 and 12 across patients.
prop_summary <- ddply(m_pop_stats, .(Marker, PTID, VISITNO), summarize, avg_prop = mean(Proportion))

prop_summary$marker_group <- "Other"
prop_summary$marker_group <- with(prop_summary,
                                  replace(marker_group, grep("cd4/", Marker), "CD4"))
prop_summary$marker_group <- with(prop_summary,
                                  replace(marker_group, grep("cd8/", Marker), "CD8"))

# Now, we clean up the marker names.
prop_summary$Marker <- gsub(pattern = "!cd[48]/", replace = "!", x = prop_summary$Marker)
markers_split <- strsplit(prop_summary$Marker, split = "&")
prop_summary$Marker <- sapply(markers_split, function(marker_split) {
  paste(sapply(strsplit(marker_split, split = "/"), tail, n = 1), collapse = "&")
})

# Adds treatment group information to the proportion summary
treatment_info <- data.frame(PTID = gsub("-", "", as.character(treatment.HVTN065$Ptid)),
                             Treatment = "Treatment", stringsAsFactors = FALSE)
treatment_info$Treatment <- replace(treatment_info$Treatment, grep("^Placebo", treatment.HVTN065$rx), "Placebo")

prop_summary <- plyr::join(prop_summary, treatment_info)
@ 

<<proportions_by_visit>>=
p <- ggplot(subset(prop_summary, marker_group == "Other"), aes(x = PTID, fill = VISITNO))
p <- p + geom_bar(aes(weight = avg_prop), position = "dodge")
p <- p + facet_wrap(~ Marker, scale = "free") + theme_bw() + scale_x_discrete(breaks = NULL)
p + theme(axis.text.x = element_text(angle = 90)) + ylab("Average Proportion Across Stimulation Groups")

p <- ggplot(subset(prop_summary, marker_group == "CD4"), aes(x = PTID, fill = VISITNO))
p <- p + geom_bar(aes(weight = avg_prop), position = "dodge")
p <- p + facet_wrap(~ Marker, scale = "free") + theme_bw() + scale_x_discrete(breaks = NULL)
p + theme(axis.text.x = element_text(angle = 90)) + ylab("Average Proportion Across Stimulation Groups")

p <- ggplot(subset(prop_summary, marker_group == "CD8"), aes(x = PTID, fill = VISITNO))
p <- p + geom_bar(aes(weight = avg_prop), position = "dodge")
p <- p + facet_wrap(~ Marker, scale = "free") + theme_bw() + scale_x_discrete(breaks = NULL)
p + theme(axis.text.x = element_text(angle = 90)) + ylab("Average Proportion Across Stimulation Groups")
@ 

<<proportions_by_treatment>>=
p <- ggplot(subset(prop_summary, marker_group == "Other"), aes(x = VISITNO, y = avg_prop))
p <- p + geom_boxplot(aes(fill = Treatment)) + scale_x_discrete(labels = c("Pre", "Post"))
p <- p + facet_wrap( ~ Marker, scale = "free")
p + xlab("Vaccination Status") + ylab("Average Proportion Across Stimulation Groups")

p <- ggplot(subset(prop_summary, marker_group == "CD4"), aes(x = VISITNO, y = avg_prop))
p <- p + geom_boxplot(aes(fill = Treatment)) + scale_x_discrete(labels = c("Pre", "Post"))
p <- p + facet_wrap( ~ Marker, scale = "free")
p + xlab("Vaccination Status") + ylab("Average Proportion Across Stimulation Groups") + ggtitle('CD4 Cytokines')

p <- ggplot(subset(prop_summary, marker_group == "CD8"), aes(x = VISITNO, y = avg_prop))
p <- p + geom_boxplot(aes(fill = Treatment)) + scale_x_discrete(labels = c("Pre", "Post"))
p <- p + facet_wrap( ~ Marker, scale = "free")
p + xlab("Vaccination Status") + ylab("Average Proportion Across Stimulation Groups") + ggtitle('CD8 Cytokines')

@ 

\section{Classification Summary}

<<classification_summary>>=
# For a patient at a given visit number, we average the proportions of the two
# control samples within each marker.
m_pop_stats <- ddply(m_pop_stats, .(PTID, VISITNO, Stimulation, Marker),
                     summarize, Proportion = mean(Proportion))

ENV_data <- subset(m_pop_stats, Stimulation != "GAG-1-PTEG")
GAG_data <- subset(m_pop_stats, Stimulation != "ENV-1-PTEG")

# Next, we normalize the population proportions for the stimulated samples to
# adjust for the background (negative controls) by calculating the difference of
# the proportions for the stimulated samples and the negative controls.
ENV_data <- ddply(ENV_data, .(PTID, VISITNO, Marker), summarize,
                  diff_Proportion = diff(Proportion))
GAG_data <- ddply(GAG_data, .(PTID, VISITNO, Marker), summarize,
                  diff_Proportion = diff(Proportion))

# Converts the melted data.frame to a wider format to continue the classification study.
ENV_data <- dcast(ENV_data, PTID + VISITNO ~ Marker, value.var = "diff_Proportion")
ENV_data <- plyr:::join(ENV_data, treatment_info)
ENV_data$PTID <- as.character(ENV_data$PTID)

GAG_data <- dcast(GAG_data, PTID + VISITNO ~ Marker, value.var = "diff_Proportion")
GAG_data <- plyr:::join(GAG_data, treatment_info)
GAG_data$PTID <- as.character(GAG_data$PTID)

# Per Greg, we apply the following classification study:
# 1. Remove placebos before subsetting treatment group train classifier.
# 2. Predict placebos (should expect poor classification accuracy because there
#    should be no separation in the placebos)
# 3. Predict test data set (should expect good results)
ENV_placebo_data <- subset(ENV_data, Treatment == "Placebo", select = -Treatment)
ENV_treatment_data <- subset(ENV_data, Treatment == "Treatment", select = -Treatment)

GAG_placebo_data <- subset(GAG_data, Treatment == "Placebo", select = -Treatment)
GAG_treatment_data <- subset(GAG_data, Treatment == "Treatment", select = -Treatment)

# We randomly choose 60% of treated patients as training data and the remaining
# patients as test data.
set.seed(42)
train_pct <- 0.6

# Partitions ENV data for classification study
ENV_treated_patients <- unique(ENV_treatment_data$PTID)
num_ENV_treated_patients <- length(ENV_treated_patients)
ENV_patients_train <- sample.int(num_ENV_treated_patients,
                                 train_pct * num_ENV_treated_patients)

ENV_train_data <- subset(ENV_treatment_data,
                         PTID %in% ENV_treated_patients[ENV_patients_train])
ENV_test_data <- subset(ENV_treatment_data,
                        PTID %in% ENV_treated_patients[-ENV_patients_train])

ENV_train_x <- as.matrix(subset(ENV_train_data, select = -c(PTID, VISITNO)))
ENV_train_y <- ENV_train_data$VISITNO

ENV_test_x <- as.matrix(subset(ENV_test_data, select = -c(PTID, VISITNO)))
ENV_test_y <- ENV_test_data$VISITNO

ENV_placebo_x <- as.matrix(subset(ENV_placebo_data, select = -c(PTID, VISITNO)))
ENV_placebo_y <- ENV_placebo_data$VISITNO

# Partitions GAG data for classification study
GAG_treated_patients <- unique(GAG_treatment_data$PTID)
num_GAG_treated_patients <- length(GAG_treated_patients)
GAG_patients_train <- sample.int(num_GAG_treated_patients,
                                 train_pct * num_GAG_treated_patients)

GAG_train_data <- subset(GAG_treatment_data, PTID %in% GAG_treated_patients[GAG_patients_train])
GAG_test_data <- subset(GAG_treatment_data,
                        PTID %in% GAG_treated_patients[-GAG_patients_train])

GAG_train_x <- as.matrix(subset(GAG_train_data, select = -c(PTID, VISITNO)))
GAG_train_y <- GAG_train_data$VISITNO

GAG_test_x <- as.matrix(subset(GAG_test_data, select = -c(PTID, VISITNO)))
GAG_test_y <- GAG_test_data$VISITNO

GAG_placebo_x <- as.matrix(subset(GAG_placebo_data, select = -c(PTID, VISITNO)))
GAG_placebo_y <- GAG_placebo_data$VISITNO

# Trains the 'glmnet' classifier using cross-validation.
ENV_glmnet_cv <- cv.glmnet(x = ENV_train_x, y = ENV_train_y, family = "binomial")
GAG_glmnet_cv <- cv.glmnet(x = GAG_train_x, y = GAG_train_y, family = "binomial")

# Computes ENV accuracy
ENV_predictions_treated <- as.vector(predict(ENV_glmnet_cv, ENV_test_x,
                                             s = "lambda.min", type = "class"))
ENV_predictions_placebo <- as.vector(predict(ENV_glmnet_cv, ENV_placebo_x,
                                             s = "lambda.min", type = "class"))
ENV_accuracy_treated <- mean(ENV_predictions_treated == ENV_test_y)
ENV_accuracy_placebo <- mean(ENV_predictions_placebo == ENV_placebo_y)

# Computes GAG accuracy
GAG_predictions_treated <- as.vector(predict(GAG_glmnet_cv, GAG_test_x,
                                             s = "lambda.min", type = "class"))
GAG_predictions_placebo <- as.vector(predict(GAG_glmnet_cv, GAG_placebo_x,
                                             s = "lambda.min", type = "class"))
GAG_accuracy_treated <- mean(GAG_predictions_treated == GAG_test_y)
GAG_accuracy_placebo <- mean(GAG_predictions_placebo == GAG_placebo_y)


# Determines which features should be kept for classification
# If present, we manually remove the "(Intercept)"
ENV_coef_glmnet <- coef(ENV_glmnet_cv)
ENV_markers_kept <- rownames(ENV_coef_glmnet)[as.vector(ENV_coef_glmnet) != 0]
ENV_markers_kept <- ENV_markers_kept[!grepl("(Intercept)", ENV_markers_kept)]

GAG_coef_glmnet <- coef(GAG_glmnet_cv)
GAG_markers_kept <- rownames(GAG_coef_glmnet)[as.vector(GAG_coef_glmnet) != 0]
GAG_markers_kept <- GAG_markers_kept[!grepl("(Intercept)", GAG_markers_kept)]
@ 


<<classification_results, results='asis'>>=
classification_results <- rbind.data.frame(c(ENV_accuracy_treated, ENV_accuracy_placebo),
                                           c(GAG_accuracy_treated, GAG_accuracy_placebo))
colnames(classification_results) <- c("Treatment", "Placebo")
rownames(classification_results) <- c("ENV", "GAG")

xtable(classification_results, digits = 3, caption = "Classification Results")
@ 


<<ROC>>=

# We use the 'ROCR' package to construct ROC curves for each of the GAG and ENV
# stimulations.
ENV_probs <- 1 - as.vector(predict(ENV_glmnet_cv, ENV_test_x, s = "lambda.min", type = "response"))
ENV_prediction <- prediction(ENV_probs, ENV_test_y)
ENV_performance <- performance(ENV_prediction, "tpr", "fpr")
ENV_cutoffs <- performance(ENV_prediction, "acc")

GAG_probs <- 1 - as.vector(predict(GAG_glmnet_cv, GAG_test_x, s = "lambda.min", type = "response"))
GAG_prediction <- prediction(GAG_probs, GAG_test_y)
GAG_performance <- performance(GAG_prediction, "tpr", "fpr")
GAG_cutoffs <- performance(GAG_prediction, "acc")

# Next, we combine the ROC curves for each stimulation to construct a singlet
# ggplot2 figure to plot the False Positive Rate vs True Positive Rate.
stim_performance <- rbind.data.frame(
  cbind(ENV_performance@x.values[[1]], ENV_performance@y.values[[1]], "ENV"),
  cbind(GAG_performance@x.values[[1]], GAG_performance@y.values[[1]], "GAG")
)
colnames(stim_performance) <- c("FPR", "TPR", "Stimulation")
stim_performance$FPR <- as.numeric(as.character(stim_performance$FPR))
stim_performance$TPR <- as.numeric(as.character(stim_performance$TPR))

# Next, we combine the ROC curves for each stimulation to construct a singlet
# ggplot2 figure to plot the False Positive Rate vs True Positive Rate.
stim_cutoffs <- rbind.data.frame(
  cbind(ENV_cutoffs@x.values[[1]], ENV_cutoffs@y.values[[1]], "ENV"),
  cbind(GAG_cutoffs@x.values[[1]], GAG_cutoffs@y.values[[1]], "GAG")
)
colnames(stim_cutoffs) <- c("Cutoff", "Accuracy", "Stimulation")
stim_cutoffs$Cutoff <- as.numeric(as.character(stim_cutoffs$Cutoff))
stim_cutoffs$Accuracy <- as.numeric(as.character(stim_cutoffs$Accuracy))


p <- ggplot(stim_performance, aes(x = FPR, y = TPR, color = Stimulation))
p + geom_line(aes(linetype = Stimulation)) + ggtitle("ROC Curve by Stimulation")

# The cutoff value on the x-axis is the probability threshold used to determine
# if a sample is classified as post-vaccine. For instance, if the threshold is
# 0.6, then samples with probability estimates of class membership above 0.6 are
# classified as post-vaccine.
# The classification accuracy is given on the y-axis.
p <- ggplot(stim_cutoffs, aes(x = Cutoff, y = Accuracy, color = Stimulation))
p + geom_line(aes(linetype = Stimulation)) + ggtitle("Accuracy by Probability Threshold")

@ 

<<markers>>=
print(ENV_markers_kept)
print(GAG_markers_kept)
@ 

<<manual_gates>>=

HVTN065_manual_gates <- subset(HVTN065_manual_gates, ANTIGEN %in% c("ENV-1-PTEG", "GAG-1-PTEG", "negctrl"))
HVTN065_manual_gates <- subset(HVTN065_manual_gates, PTID %in% levels(m_pop_stats$PTID))
HVTN065_manual_gates <- subset(HVTN065_manual_gates, VISITNO %in% c(2, 12))

manual_counts <- ddply(HVTN065_manual_gates, .(PTID, VISITNO, ANTIGEN), function(x) {
  counts <- data.frame(
    PTID = x$PTID[1],
    VISITNO = x$VISITNO[1],
    ANTIGEN = x$ANTIGEN[1],
    root = no_commas(x$COLLECTCT)[1],
    Singlet = no_commas(x$SUBSET1_NUM)[1],
    Live = no_commas(x$SUBSET2_NUM)[1],
    Lymphocytes = no_commas(x$SUBSET3_NUM)[1],
    CD3 = no_commas(x$SUBSET4_NUM)[1],
    stringsAsFactors = FALSE
  )
  # To grab the appropriate counts from the CD4 and CD8 subtrees, we split the
  # data.
  x_CD4 <- subset(x, SUBSET5 == "CD4+")
  x_CD8 <- subset(x, SUBSET5 == "CD8+")
  
  counts$CD4 <- no_commas(x_CD4$SUBSET5_NUM)[1]
  counts$CD8 <- no_commas(x_CD8$SUBSET5_NUM)[1]
  
  # CD4 Cytokine Counts
  for (i in seq_len(nrow(x_CD4))) {
    cytokine_name <- paste0("CD4:", x_CD4$SUBSET6[i])
    cytokine_count <- no_commas(x_CD4$SUBSET6_NUM[i])
    counts[[cytokine_name]] <- cytokine_count
  }
  
  # CD8 Cytokine Counts
  for (i in seq_len(nrow(x_CD8))) {
    cytokine_name <- paste0("CD8:", x_CD8$SUBSET6[i])
    cytokine_count <- no_commas(x_CD8$SUBSET6_NUM[i])
    counts[[cytokine_name]] <- cytokine_count
  }

  counts
})

# Calculates the proportions for the manual gates
manual_proportions <- ddply(manual_counts, .(PTID, VISITNO, ANTIGEN), function(x) {
  proportions <- with(x, data.frame(
    PTID = PTID,
    VISITNO = VISITNO,
    ANTIGEN = ANTIGEN,
    Singlet = Singlet / root,
    Live = Live / Singlet,
    Lymphocytes = Lymphocytes / Live,
    CD3 = CD3 / Lymphocytes,
    CD4 = CD4 / CD3,
    CD8 = CD8 / CD3))
  
  for (CD4_cytokine in colnames(x)[grep("CD4:", colnames(x))]) {
    proportions[[CD4_cytokine]] <- x[[CD4_cytokine]] / x[["CD4"]]
  }
  
  for (CD8_cytokine in colnames(x)[grep("CD8:", colnames(x))]) {
    proportions[[CD8_cytokine]] <- x[[CD8_cytokine]] / x[["CD8"]]
  }

  proportions
})


@ 


\end{document}
